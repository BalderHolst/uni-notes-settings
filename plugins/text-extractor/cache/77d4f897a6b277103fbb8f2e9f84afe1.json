{"path":"Lessons/Semester 2/microcontrolers/Lesson 3.pdf","text":"Lesson 3 1 Multiplexer (MUX) 2 Multiplexer (MUX), or Selector â€¢ Selects one of the N inputs to connect it to the output â€¢ based on the value of a log2N-bit control input called select â€¢ Example: 2-to-1 MUX S Y 0 D0 1 D1 Multiplexer (MUX), or Selector (II) â€¢ Selects one of the N inputs to connect it to the output â€¢ based on the value of a log2N-bit control input called select â€¢ Example: 2-to-1 MUX â€¢ S=1 â€¢ A AND 0 = 0 â€¢ B AND 1 = B â€¢ B OR 0 = B A B S C ba S=1 0 B B S=0 A 0 A â€¢ S=0 â€¢ A AND 1 = A â€¢ B AND 0 = 0 â€¢ A OR 0 = A Multiplexer (MUX), or Selector (III) â€¢ The output C is always connected to either the input A or the input B â€¢ Output value depends on the value of the select line S 5 A B S C S C 0 A 1 B Aside: Logic Using Multiplexers â€¢ Multiplexers can be used as lookup tables to perform logic functions 7 Aside: Logic Using Multiplexers (II) â€¢ Multiplexers can be used as lookup tables to perform logic functions 8 Aside: Logic Using Multiplexers (III) â€¢ Multiplexers can be used as lookup tables to perform logic functions 9 3X1 Mux Aside: Logic Using Multiplexers (III) â€¢ How to implement the same logic by 2X1 MUX? 10 2X1 Mux 00 01 10 11 Decoder 11 Decoder â€¢ â€œInput pattern detectorâ€ â€¢ n inputs and 2n outputs â€¢ Exactly one of the outputs is 1 and all the rest are 0s â€¢ The one output that is logically 1 is the output corresponding to the input pattern that the logic circuit is expected to detect â€¢ Example: 2-to-4 decoder 12 Decoder (I) â€¢ n inputs and 2n outputs â€¢ Exactly one of the outputs is 1 and all the rest are 0s â€¢ The one output that is logically 1 is the output corresponding to the input pattern that the logic circuit is expected to detect A 1 if A,B is 00 B 1 if A,B is 01 1 if A,B is 10 1 if A,B is 11 A = 1 0 B = 0 0 1 0 Decoder (II) â€¢ The decoder is useful in determining how to interpret a bit pattern 14 A = 1 0 B = 0 0 1 0 â‘ It could be the address of a row in DRAM, that the processor intends to read from â‘ It could be an instruction in the program and the processor has to decide what action to do! (based on instruction opcode) Full Adder 15 Full Adder (I) â€¢ Binary addition â€¢ Similar to decimal addition â€¢ From right to left â€¢ One column at a time â€¢ One sum and one carry bit â€¢ Truth table of binary addition on one column of bits within two n-bit operands 16 ğ’‚ğ’âˆ’ğŸğ’‚ğ’âˆ’ğŸ â€¦ ğ’‚ğŸğ’‚ğŸ ğ’ƒğ’âˆ’ğŸğ’ƒğ’âˆ’ğŸ â€¦ ğ’ƒğŸğ’ƒğŸ ğ‘ºğ’âˆ’ğŸ â€¦ ğ‘ºğŸğ‘ºğŸ ğ‘ªğ’ ğ‘ªğ’âˆ’ğŸ â€¦ ğ‘ªğŸ ai bi Si 0 0 0 0 1 0 10 0 11 1 carryi carryi+1 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0 0 0 1 1 1 0 1 1 0 1 0 0 1 Full Adder (II) â€¢ Binary addition â€¢ N 1-bit additions â€¢ SOP of 1-bit addition 17 ğ’‚ğ’âˆ’ğŸğ’‚ğ’âˆ’ğŸ â€¦ ğ’‚ğŸğ’‚ğŸ ğ’ƒğ’âˆ’ğŸğ’ƒğ’âˆ’ğŸ â€¦ ğ’ƒğŸğ’ƒğŸ ğ‘ºğ’âˆ’ğŸ â€¦ ğ‘ºğŸğ‘ºğŸ ğ‘ªğ’ ğ‘ªğ’âˆ’ğŸ â€¦ ğ‘ªğŸ ai bi Si 0 0 0 0 1 0 10 0 11 1 carryi carryi+1 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0 0 0 1 1 1 0 1 1 0 1 0 0 1 Full Adder ai bi ci ai bi ci ci+1 si Full Adder (1 bit) 4-Bit Adder from Full Adders â€¢ Creating a 4-bit adder out of 1-bit full adders â€¢ To add two 4-bit binary numbers A and B 18 ğ’‚ğŸ‘ ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ ğ’ƒğŸ‘ ğ’ƒğŸ ğ’ƒğŸ ğ’ƒğŸ ğ’”ğŸ‘ ğ’”ğŸ ğ’”ğŸ ğ’”ğŸ ğ’„ğŸ’ ğ’„ğŸ‘ ğ’„ğŸ ğ’„ğŸ + ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ + Full Adder a0b0 s0 0c1 Full Adder a1b1 s1 c2 Full Adder a2b2 s2 c3 Full Adder a3b3 s3 c4 Adder Design: Ripple Carry Adder â€¢ Delay propagation problem 19 Adder Design: Carry Lookahead Adder 20 ALU (Arithmetic Logic Unit) 21 ALU (Arithmetic Logic Unit) â€¢ Combines a variety of arithmetic and logical operations into a single unit (that performs only one function at a time) â€¢ Usually denoted with this symbol: Example ALU (Arithmetic Logic Unit) 23 Tri-State Buffer 24 Tri-State Buffer â€¢ A tri-state buffer enables gating of different signals onto a wire â€¢ Floating signal (Z): Signal that is not driven by any circuit â€¢ Open circuit, floating wire 25 Example: Use of Tri-State Buffers â€¢ Imagine a wire connecting the CPU and memory â€¢ At any time only the CPU or the memory can place a value on the wire, both not both â€¢ You can have two tri-state buffers: one driven by CPU, the other memory; and ensure at most one is enabled at any time 26 Example Design with Tri-State Buffers 27 CPU Memory GateMem GateCPU Shared Bus Another Example â€¢ Shared Bus is a common line between peripherals â€¢ All of the devices connected with Tri-State Buffers â€¢ When a device use the shared bus all other buffers are disconnected. 28 Multiplexer Using Tri-State Buffers 29 Karnaugh Maps (K-Maps) 30 Complex Cases â€¢ One example â€¢ Problem â€¢ Easy to see how to apply Uniting Theoremâ€¦ â€¢ Hard to know if you applied it in all the right placesâ€¦ â€¢ â€¦especially in a function of many more variables â€¢ Question â€¢ Is there an easier way to find potential simplifications? â€¢ i.e., potential applications of Uniting Theoremâ€¦? â€¢ Answer â€¢ Need an intrinsically geometric representation for Boolean f( ) â€¢ Something we can draw, seeâ€¦ 31 ğ‘ªğ’ğ’–ğ’• = à´¥ğ‘¨ğ‘©ğ‘ª + ğ‘¨à´¥ğ‘©ğ‘ª + ğ‘¨ğ‘©à´¥ğ‘ª + ğ‘¨ğ‘©ğ‘ª Karnaugh Map â€¢ Karnaugh Map (K-map) method â€¢ K-map is an alternative method of representing the truth table that helps visualize adjacencies in up to 6 dimensions â€¢ Physical adjacency â†” Logical adjacency 32 2-variable K-map 0 1 0 00 01 1 10 11 Numbering Scheme: 00, 01, 11, 10 is called a â€œGray Codeâ€ â€” only a single bit (variable) changes from one code word and the next code word 00 01 11 10 00 0000 0001 0011 0010 01 0100 0101 0111 0110 11 1100 1101 1111 1110 10 1000 1001 1011 1010 3-variable K-map 4-variable K-map 00 01 11 10 0 000 001 011 010 1 100 101 111 110 ğ‘¨ğ‘©ğ‘¨ ğ‘© ğ‘ªğ‘« ğ‘¨ ğ‘©ğ‘ª Karnaugh Map Methods 33 Adjacent 000 001 010 011 110 111 100 101 000 001 010 011 110 111 100 101 Adjacent K-map adjacencies go â€œaround the edgesâ€ Wrap around from first to last column Wrap around from top row to bottom row 00 01 11 10 0 000 001 011 010 1 100 101 111 110 ğ‘¨ ğ‘©ğ‘ª K-map Cover - 4 Input Variables 34 00 01 11 10 00 1 0 0 1 01 0 1 0 0 11 1 1 1 1 10 1 1 1 1 ğ‘¨ğ‘© ğ‘ªğ‘« Strategy for â€œcirclingâ€ rectangles on Kmap: As big as possible Biggest â€œoops!â€ that people forget: Wrap-arounds ğ… = ğ€ + à´¥ğ‘©à´¥ğ‘« + ğà´¥ğ‘ªğ‘«ğ€ + à´¥ğ‘©à´¥ğ‘«ğ€ Logic Minimization Using K-Maps â€¢ Very simple guideline: â€¢ Circle all the rectangular blocks of 1â€™s in the map, using the fewest possible number of circles â€¢ Each circle should be as large as possible â€¢ Read off the implicants that were circled â€¢ More formally: â€¢ A Boolean equation is minimized when it is written as a sum of the fewest number of prime implicants â€¢ Each circle on the K-map represents an implicant â€¢ The largest possible circles are prime implicants 35 K-map Rules â€¢ What can be legally combined (circled) in the K-map? â€¢ Rectangular groups of size 2k for any integer k â€¢ Each cell has the same value (1, for now) â€¢ All values must be adjacent â€¢ Wrap-around edge is okay â€¢ How does a group become a term in an expression? â€¢ Determine which literals are constant, and which vary across group â€¢ Eliminate varying literals, then AND the constant literals â€¢ constant 1 â™ use ğ—, constant 0 â™ use à´¥ğ‘¿ â€¢ What is a good solution? â€¢ Biggest groupings â™ eliminate more variables (literals) in each term â€¢ Fewest groupings â™ fewer terms (gates) all together â€¢ OR together all AND terms you create from individual groups 36 K-map Example: Two-bit Comparator Design Approach: Write a 4-Variable K-map for each of the 3 output functions 37 A B C D F1 F2 F3 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 0 0 1 1 1 0 1 0 1 0 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1 1 0 0 0 0 1 1 1 0 1 0 0 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 A F1 AB = CD B F2 AB < CD C F3 AB > CD D K-map Example: Two-bit Comparator (2) 38 00 01 11 10 00 1 01 1 11 1 10 1 K-map for F1 ğ‘¨ğ‘© ğ‘ªğ‘« A B C D F1 F2 F3 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 0 0 1 1 1 0 1 0 1 0 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1 1 0 0 0 0 1 1 1 0 1 0 0 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0F1 = A'B'C'D' + A'BC'D + ABCD + AB'CD' ğ‘¨ ğ‘© ğ‘« ğ‘ª K-map Example: Two-bit Comparator (3) 39 A B C D F1 F2 F3 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 0 0 1 1 1 0 1 0 1 0 0 0 0 0 1 1 0 0 1 0 0 1 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1 1 0 0 0 0 1 1 1 0 1 0 0 1 1 1 1 0 0 0 1 1 1 1 1 1 0 0 00 01 11 10 00 1 1 1 01 1 1 11 10 1 K-map for F2 ğ‘¨ğ‘© ğ‘ªğ‘« F2 = A'C + A'B'D + B'CD F3 = ? (Exercise for you) ğ‘¨ ğ‘© ğ‘« ğ‘ª Sequential Logic Circuits and Design â€¢ Circuits that can store information â€¢ Cross-coupled inverter â€¢ R-S Latch â€¢ Gated D Latch â€¢ D Flip-Flop â€¢ Register 40 Introduction â€¢ Combinational circuit output depends only on current input â€¢ We want circuits that produce output depending on current and past input values â€“ circuits with memory â€¢ How can we design a circuit that stores information? 41 Capturing Data 42 Basic Element: Cross-Coupled Inverters â€¢ Has two stable states: Q=1 or Q=0. â€¢ Has a third possible â€œmetastableâ€ state with both outputs oscillating between 0 and 1 (we will see this later) â€¢ Not useful without a control mechanism for setting Q Image source: Harris and Harris, Digital Design and Computer Architecture, 2nd Ed., p.110. 43 More Realistic Storage Elements â€¢ Have a control mechanism for setting Q â€¢ We will see the R-S latch soon â€¢ Letâ€™s look at an SRAM (static random access memory) cell first â€¢ We will get back to SRAM (and DRAM) later wordline bitline bitline SRAM cell 44 The Big Picture: Storage Elements â€¢ Latches and Flip-Flops â€¢ Very fast, parallel access â€¢ Very expensive (one bit costs tens of transistors) â€¢ Static RAM (SRAM) â€¢ Relatively fast, only one data word at a time â€¢ Expensive (one bit costs 6+ transistors) â€¢ Dynamic RAM (DRAM) â€¢ Slower, one data word at a time, reading destroys content (refresh), needs special process for manufacturing â€¢ Cheap (one bit costs only one transistor plus one capacitor) â€¢ Other storage technology (flash memory, hard disk, tape) â€¢ Much slower, access takes a long time, non-volatile â€¢ Very cheap 45 Basic Storage Element: The R-S Latch 46 The R-S (Reset-Set) Latch â€¢ Cross-coupled NAND gates â€¢ Data is stored at Q (inverse at Qâ€™) â€¢ S and R are control inputs â€¢ In quiescent (idle) state, both S and R are held at 1 â€¢ S (set): drive S to 0 (keeping R at 1) to change Q to 1 â€¢ R (reset): drive R to 0 (keeping S at 1) to change Q to 0 â€¢ S and R should never both be 0 at the same time S R Qâ€™ Q Input Output R S Q 1 1 Qprev 1 0 1 0 1 0 0 0 Forbidden 47 10 Why not R=S=0? 1. If R=S=0, Q and Qâ€™ will both settle to 1, which breaks our invariant that Q = !Qâ€™ 2. If S and R transition back to 1 at the same time, Q and Qâ€™ begin to oscillate between 1 and 0 because their final values depend on each other (metastability) â€¢ This eventually settles depending on variation in the circuits S R Qâ€™ Q Input Output R S Q 1 1 Qprev 1 0 1 0 1 0 0 0 Forbidden 10 0 01 1 48 The Gated D Latch 49 The Gated D Latch â€¢ How do we guarantee correct operation of an R-S Latch? S R Qâ€™ Q 50 The Gated D Latch â€¢ How do we guarantee correct operation of an R-S Latch? â€¢ Reduce the number of states to three: â€¢ WE/Clock =1, D=1, Q=1 â€¢ WE/Clock =1, D=0, Q=0 â€¢ WE/Clock =0, D=X â€¢ Q takes the value of D, when write enable (WE) is set to 1 â€¢ S and R can never be 0 at the same time! S R Qâ€™ Q WE/ Clock D 51 Input Output WE D Q 0 0 Qprev 0 1 Qprev 1 0 0 1 1 1 The Register 52 The Register D Q How can we use D latches to store more data? â€¢ Use more D latches! â€¢ A single Clock signal for all latches for simultaneous writes D2 Q2 D1 Q1 D0 Q0 3 3 Clock Here we have a register, or a structure that stores more than one bit and can be read from and written to This register holds 4 bits, and its data is referenced as Q[3:0] 53 The Register How can we use D latches to store more data? â€¢ Use more D latches! â€¢ A single Clock signal for all latches for simultaneous writes Register x (Rx) D3:0 Q3:0 WE 4 4 Here we have a register, or a structure that stores more than one bit and can be read from and written to This register holds 4 bits, and its data is referenced as Q[3:0] 54","libVersion":"0.2.4","langs":""}